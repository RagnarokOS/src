'\" -*- coding: UTF-8 -*-
.\" Copyright (C) 1998-2001 Miquel van Smoorenburg.
.\"
.\" This program is free software; you can redistribute it and/or modify
.\" it under the terms of the GNU General Public License as published by
.\" the Free Software Foundation; either version 2 of the License, or
.\" (at your option) any later version.
.\"
.\" This program is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public License
.\" along with this program; if not, write to the Free Software
.\" Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
.\"
.\"{{{}}}
.\"{{{  Title
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH INITTAB 5 "4 Dezembro, 2001" "sysvinit " "Formatos de Ficheiro"
.\"}}}
.\"{{{  Name
.SH NOME
.\"}}}
.\"{{{  Description
inittab \- formato do ficheiro inittab usando pelo processo init compatível
com sysv
.SH DESCRIÇÃO
O ficheiro \fBinittab\fP descreve quais processos são iniciados no arranque e
durante a operação normal (ex. \& /etc/init.d/boot, /etc/init.d/rc,
gettys...).  O \fBinit\fP(8)  distingue múltiplos \fIrunlevels\fP, cada um dos
quais pode ter o seu próprio conjunto de processos que é arrancado. Os
runlevels válidos são \fB0\fP\-\fB6\fP mais \fBA\fP, \fBB\fP, e \fBC\fP para entradas
\fBondemand\fP.  Uma entrada no ficheiro \fBinittab\fP tem o seguinte formato:
.RS
.sp
\fIid\fP:\fIrunlevels\fP:\fIaction\fP:\fIprocess\fP
.sp
.RE
.\"{{{  id
As linhas que começam com `#' são ignoradas.
.IP \fIid\fP
é uma sequência única de 1\-4 caracteres que identifica uma entrada em
\fBinittab\fP (para versões do sysvinit compiladas com a \fIantiga\fP libc5 (<
5.2.18) ou bibliotecas a.out o limite é de 2 caracteres).
.sp
.\"}}}
.\"{{{  runlevels
Nota: tradicionalmente, para o getty e outros processos de login, este valor
do campo \fIid\fP é mantido no mesmo que o sufixo do tty correspondente, ex. \&
\fB1\fP para \fBtty1\fP. Alguns programas antigos de contabilidade de login podem
esperar isto, apesar de não me lembrar de nenhum.
.IP \fIrunlevels\fP
.\"}}}
.\"{{{  action
lista os runlevels para os quais a acção especificada deve ser tomada.
.IP \fIaction\fP
.\"}}}
.\"{{{  process
descreve qual a acção que deve ser tomada.
.IP \fIprocess\fP
especifica o processo a ser executado. Se o campo de processo começar com um
caractere `+', o \fBinit\fP não irá contabilizar tmp e wtmp para esse
processo. Isto é preciso para gettys que insistem em fazer a sua própria
limpeza utmp/wtmp. Isto é também um bug histórico. O comprimento deste campo
está limitado a 127 caracteres.

.\"'<>?
Por favor note que incluir certos caracteres no campo de processo irá
resultar no \fBinit\fP a tentar lançar uma shell para interpretar o comando
contido no campo de processo. Os caracteres que pode despoletar uma shell
são: \fB~`!$^&*()=|\{}[];\fP

Em sistemas que não tenham uma shell para ser lançada ou quais não se deseja
usar uma shell para interpretar o campo do processo, o campo de processo
pode ser prefixado com o símbolo @. O @ irá ser ignorado e tudo o que se
segue será tratado como o comando a ser lançado, literalmente, pelo serviço
\fBinit\fP.

Em casos que ambos sinais + e @ vão ser usados (para desligar os relatórios
e interpretação da shell) coloque o sinal + antes do símbolo @. Ambas
bandeiras irão ser lidadas e depois tudo o que se segue ao @ irá ser lidado
pelo \fBinit\fP

.\"}}}
.PP
O campo \fIrunlevels\fP pode conter vários caracteres para diferentes
runlevels. Por exemplo, \fB123\fP especifica que o processo deve ser iniciado
nos runlevels 1, 2, e 3. Os \fIrunlevels\fP para entradas \fBondemand\fP podem
conter um \fBA\fP, \fBB\fP, ou \fBC\fP. O campo \fIrunlevels\fP das entradas \fBsysinit\fP,
\fBboot\fP, e \fBbootwait\fP é ignorado.
.PP
Quando o runlevel do sistema é mudado, quaisquer processos a correr que não
estão especificados para o novo runlevel são mortos, primeiro com
\s-2SIGTERM\s0, e depois com \s-2SIGKILL\s0.
.PP
.\"{{{  respawn
As acções válidas para o campo \fIaction\fP são:
.IP \fBrespawn\fP
.\"}}}
.\"{{{  wait
O processo será reiniciado sempre que termine (ex. \& getty).
.IP \fBwait\fP
.\"}}}
.\"{{{  once
O processo irá ser iniciado assim que se entra no runlevel especificado e o
\fBinit\fP irá esperar pelo seu término.
.IP \fBonce\fP
.\"}}}
.\"{{{  boot
O processo irá ser executado uma vez quando se entra no runlevel
especificado.
.IP \fBboot\fP
.\"}}}
.\"{{{  bootwait
O processo será executado durante o arranque do sistema. O campo
\fIrunlevels\fP é ignorado.
.IP \fBbootwait\fP
.\"}}}
.\"{{{  off
O processo será executado durante o arranque do sistema, enquanto \fBinit\fP
espera pelo seu término (ex. \& /etc/rc). O campo \fIrunlevels\fP é ignorado.
.IP \fBoff\fP
.\"}}}
.\"{{{  ondemand
Isto não faz nada.
.IP \fBondemand\fP
.\"}}}
.\"{{{  initdefault
Um processo marcado com um runlevel \fBondemand\fP será executado sempre que o
runlevel \fBondemand\fP especificado é chamado. No entanto, nenhuma mudança de
runlevel irá ocorrer (os runlevels \fBondemand\fP são `a', `b', e `c').
.IP \fBinitdefault\fP
.\"}}}
.\"{{{  sysinit
Uma entrada \fBinitdefault\fP especifica o runlevel em que se deve entrar após
o arranque do sistema. Se não existir nenhum, o \fBinit\fP irá pedir um
runlevel na consola. O campo \fIprocess\fP é ignorado.
.IP \fBsysinit\fP
.\"}}}
.\"{{{  powerwait
O processo será executado durante o arranque do sistema. Será executado
antes de qualquer entrada \fBboot\fP ou \fB bootwait\fP.  O campo \fIrunlevels\fP é
ignorado.
.IP \fBpowerwait\fP
.\"}}}
.\"{{{  powerfail
O processo será executado quando a energia vai abaixo. O \fBinit\fP é
geralmente informado disto por um processo que fala com uma UPS ligada ao
computador. O \fBinit\fP irá esperar que o processo termine antes de continuar.
.IP \fBpowerfail\fP
.\"}}}
.\"{{{  powerokwait
Como para \fBpowerwait\fP, excepto que o \fBinit\fP não espera pelo final do
processo.
.IP \fBpowerokwait\fP
.\"}}}
.\"{{{  powerfailnow
Este processo será executado assim que o \fBinit\fP é informado que a energia
foi restaurada.
.IP \fBpowerfailnow\fP
.\"}}}
.\"{{{  ctrlaltdel
Este processo será executado quando é dito ao \fBinit\fP que a bateria da UPS
externa está quase vazia e a energia está a falhar (desde que a UPS externa
e o processo de monitorização sejam capazes de detectar esta condição).
.IP \fBctrlaltdel\fP
.\"}}}
.\"{{{  kbrequest
O processo será executado quando o \fBinit\fP receber o sinal \fBSIGINT\fP. Isto
significa que alguém na consola do sistema pressionou a combinação de teclas
\fBCTRL\-ALT\-DEL\fP. Tipicamente alguém quer executar alguma espécie de
\fBshutdown\fP seja para ir para nível de único\-utilizador ou para reiniciar a
máquina.
.IP \fBkbrequest\fP
O processo será executado quando o \fBinit\fP receber um sinal a partir do
manipulador do teclado que uma combinação especial de teclas foi pressionada
no teclado da consola.
.sp
A documentação para esta função ainda não está completa; pode ser encontrada
mais informação nos pacotes kbd\-x.xx (o mais recente foi kbd\-0.94 na altura
que isto foi escrito). Basicamente você deseja mapear alguma combinação do
teclado para a acção "KeyboardSignal". Por exemplo, para mapear Alt\-SetaCima
para este objectivo use o seguinte no seu ficheiro keymaps:
.RS
.sp
alt keycode 103 = KeyboardSignal
.sp
.RE
.\"}}}
.\"}}}
.\"{{{  Examples
.SH EXEMPLOS
Isto é um exemplo de uma inittab que é semelhante à inittab antiga do Linux:
.RS
.sp
.nf
.ne 7
# inittab for linux
id:1:initdefault:
rc::bootwait:/etc/rc
1:1:respawn:/etc/getty 9600 tty1
2:1:respawn:/etc/getty 9600 tty2
3:1:respawn:/etc/getty 9600 tty3
4:1:respawn:/etc/getty 9600 tty4
.fi
.sp
.RE
Este ficheiro inittab executa \fI/etc/rc\fP durante o arranque e inicia gettys
em tty1\-tty4.
.PP
Uma \fBinittab\fP mais elaborada com diferentes runlevels (veja os comentários
no interior):
.RS
.sp
.nf
.ne 19
# Nível para onde correr
id:2:initdefault:

# Script de configuração/inicialização do sistema durante o arranque.
si::sysinit:/etc/init.d/rcS

# O que fazer em modo de único\-utilizador.
~:S:wait:/sbin/sulogin

# /etc/init.d executa os scripts S e K na comutação
# do runlevel.
#
# Runlevel 0 é parar.
# Runlevel 1 é único\-utilizador.
# Runlevels 2\-5 são multi\-utilizador.
# Runlevel 6 é reiniciar.

l0:0:wait:/etc/init.d/rc 0
l1:1:wait:/etc/init.d/rc 1
l2:2:wait:/etc/init.d/rc 2
l3:3:wait:/etc/init.d/rc 3
l4:4:wait:/etc/init.d/rc 4
l5:5:wait:/etc/init.d/rc 5
l6:6:wait:/etc/init.d/rc 6

# O que fazer na "saudação dos 3 dedos".
ca::ctrlaltdel:/sbin/shutdown \-t1 \-h now

# Runlevel 2,3: getty on virtual consoles
# Runlevel   3: getty on terminal (ttyS0) and modem (ttyS1)
1:23:respawn:/sbin/getty tty1 VC linux
2:23:respawn:/sbin/getty tty2 VC linux
3:23:respawn:/sbin/getty tty3 VC linux
4:23:respawn:/sbin/getty tty4 VC linux
S0:3:respawn:/sbin/getty \-L 9600 ttyS0 vt320
S1:3:respawn:/sbin/mgetty \-x0 \-D ttyS1

.fi
.sp
.RE
.\"}}}
.\"{{{  Files
.SH FICHEIROS
.\"}}}
.\"{{{  Author
/etc/inittab
.SH AUTOR
.\"}}}
.\"{{{  See also
\fBinit\fP foi escrito por
.MT miquels@\:cistron\:.nl
Miquel van Smoorenburg
.ME .
Este manual foi escrito por
.MT lederer@\:francium\:.informatik\:.uni\-bonn\:.de
Sebastian Lederer
.ME
e
modificado por
.MT u31b3hs@\:pool\:.informatik\:.rwth\-aachen\:.de
Michael
Haardt
.ME .
.SH "VEJA TAMBÉM"
\fBinit\fP(8), \fBtelinit\fP(8)
.\"}}}
