#!/bin/ksh

# sysupdate: update Ragnarok base system.
#
# $Id: sysupdate,v 1.2 2023/08/18 18:12:56 lecorbeau Exp $
#
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
#											#
#	Copyright (c) 2023, Ian LeCorbeau <I-LeCorbeau (at) protonmail (dot) com>	#
#											#
#	Permission to use, copy, modify, and/or distribute this software for any	#
#	purpose with or without fee is hereby granted, provided that the above		#
#	copyright notice and this permission notice appear in all copies.		#
#											#
#	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES	#
#	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF		#
#	MERCHANTABILITY AND FITNESS IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR		#
#	ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES		#
#	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN		#
#	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF		#
#	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.			#
#											#
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

. /lib/ragnarok-shlib

set -e
umask 0022
export PATH=/usr/bin:/bin:/usr/sbin:/sbin

CONF="/etc/sysupdate.conf"
TMP=$(mktemp -d -p /tmp sysupdate.XXXXXXXXXX)
MIRROR=$(getvar MIRROR "$CONF")
PUBKEY=$(getvar PUBKEY "$CONF")
VERSION=$(getvar VERSION "$CONF")
URL="${MIRROR}/${VERSION}"

usage() {
	printf '%s\n' "
Options:

-d	download, but don't install, update specified as argument 1.

-h	Show this help message.

-l	List installed updates, if there are any.

-q	Check if there are any updates available.

-r	Revert an update. Must supply name of program as argument 1.

The most common operation is to run sysupdate with no option, which will
download and install available binary updates.
"
}

# Never download stuff from the internet as the root user
# I take no credit for this function. All credit goes to
# Antoine Jacoutot, who wrote OpenBSD's syspatch(1).
unpriv() {
	local _file=$2 _ret=0 _user=_sysupdate

	if [[ $1 == -f && -n ${_file} ]]; then
		# shellcheck disable=SC2188
		>${_file}
		chown "${_user}" "${_file}"
		chmod 0711 "${TMP}"
		shift 2
	fi
	(($# >= 1))

	su -s /bin/sh ${_user} -c "$@" || _ret=$?

	[[ -n ${_file} ]] && chown root "${_file}"

	return ${_ret}
}

# Get the patches file and sig
get_file() {
	printf '%s\n' "Fetching sysupdate list..."
	cd "${TMP}" || cd
	unpriv -f "${TMP}/sysupdate.list" "wget -q --show-progress -O sysupdate.list ${URL}/sysupdate.list"
	unpriv -f "${TMP}/sysupdate.list.sig" "wget -q --show-progress -O sysupdate.list.sig ${URL}/sysupdate.list.sig"
}

# Fetching the updates
get_upd() {
	local _file="$1"

	cd "${TMP}" || cd
	unpriv -f "${TMP}/${_file}" "wget -q --show-progress -O ${_file} ${URL}/${_file}"
}

# Verify patch file sig. If signify returns a non-zero
# exit status, abort.
check_sig() {
	local _file="$1"

	if ! /usr/bin/signify -V -p "$PUBKEY" -x "${_file}".sig -m "$_file"; then
		echo "Signature verification failed. Exiting..."
		exit 1
	fi
}

# Check if there are any updates
check_update() {
	local _updates

	# Fetch update file and verify its signature
	get_file
	check_sig "${TMP}/sysupdate.list"

	_updates=$(comm -1 -3 --output-delimiter="" "/var/db/updates/sysupdate.list" "${TMP}/sysupdate.list")

	# If there are no updates, exit and return 2
	# comm is faster than diff and grep -Fxvf
	if [[ -z $_updates ]]; then
		printf '%s\n' "No updates found"
		exit 2
	else
		return 0
	fi
}

# Create a backup tarball
# Don't overcomplicate things. Any directory in rollback is a backup
# so just archive them.
create_backup() {
	local _bdir _dir=$1 _rc=0

	_bdir="/var/db/updates"

	cd "$_bdir" && \
		handle_tar -c "${_dir}.old.tgz" "${_dir}" || rc=$? && \
		rm -r "${_dir}"
	cd ..

	if ((_rc != 0)); then
		printf '%s\n' "Failed to create rollback for ${_dir}."
	fi
}

# Extract or create tarball
handle_tar() {
	local _arc=$2 _opts

	case "$1" in
		-e)	_opts="-xpzf"
			;;
		-c)	_opts="-cpzf"
	esac
	shift
	bsdtar --xattrs "$_opts" "$@"
}

# Install the updated files, preserving their permissions, and create
# backup files for rollback.
install_files() {
	local _dir=$1 _files _perms _ret=0 _u

	_files=$(find "$_dir" -type f)

	for _file in ${_files}; do
		_perms=$(stat -c "-m %a -g %g -o %G" "${_file}")
		_u=${_file##${_dir}}

		/usr/bin/install ${_perms} -b --suffix=".old" -t "$(dirname ${_u})" \
			"${_file}" || _ret=$?
	done

	if ((_ret != 0)); then
		printf '%s\n' "Failed to install ${_file}."
	fi
}

# Move the backup files to rollback dir.
mv_old() {
	local _bdir _dir=$1 _files _ret=0 _u

	_bdir="/var/db/updates"
	_files=$(find "$_dir" -type f)

	for _file in ${_files}; do
		_u=${_file##${_dir}}
		mkdir -p "${_bdir}/$(dirname ${_file##*_})"
		mv -- "${_u}.old" "${_bdir}/$(dirname ${_file##*_}/${_u##*/})" || _ret=$?
	done

	if ((_ret != 0)); then
		printf '%s\n' "Failed to move ${_u}.old"
	fi
}

do_update() {
	local _patches

	# If sysupdate.list doesn't exist yet, create it
	[[ ! -f /var/db/updates/sysupdate.list ]] && unpriv "touch /var/db/updates/sysupdate.list"

	check_update

	# shellcheck disable=SC2046	# We DO want word splitting.
	set -A _patches -- $(comm -1 -3 --output-delimiter="" /var/db/updates/sysupdate.list "${TMP}/sysupdate.list")
	printf '%s\n' "Downloading updates..." &&
	for patch in "${_patches[@]}"; do
		get_upd "${patch}.tgz"
		get_upd "${patch}.tgz.sig"
	done

	for patch in "${_patches[@]}"; do
		printf '%s\n' "Verifying $patch signature"
		check_sig "${TMP}/${patch}.tgz"
		printf '%s\n' "Installing ${patch}..."
		handle_tar -e "${TMP}/${patch}.tgz" -C "${TMP}"
		install_files "${TMP}/${patch}"
		mv_old "${TMP}/${patch}"
		printf '%s\n' "Creating rollback for ${patch##*_}..."
		create_backup "${patch##*_}"
	done
	
	# Copy the new sysupdate list to /var/db
	printf '%s\n' "Updating /var/db/updates/sysupdate.list..."
	unpriv "cat /var/db/updates/sysupdate.list > /var/db/updates/sysupdate.list.old"
	cp "${TMP}"/sysupdate.list /var/db/updates/
	# Make sure the new list is owned by the _sysupdate user
	chown _sysupdate:_sysupdate /var/db/updates/sysupdate.list

	exit 0
}

# Download update but don't install it.
do_download() {
	local _pkg

	get_file

	_pkg=$(grep "$1" "${TMP}/sysupdate.list")

	get_upd "${_pkg}.tgz"
	get_upd "${_pkg}.tgz.sig"

	# move package to /var/db/updates
	unpriv "cp ${TMP}/${_pkg}.tgz /var/db/updates/"
	unpriv "cp ${TMP}/${_pkg}.tgz.sig /var/db/updates/"
}

# List installed update
do_list() {
	printf '%s\n' "The following updates are installed:"
	cat /var/db/updates/sysupdate.list
}

# Check if updates are available.
do_query() {
	check_update
	_ret=$?

	case "$_ret" in
		0)	printf '%s\n' "
The following updates are available:
$(comm -1 -3 --output-delimiter="" "/var/db/updates/sysupdate.list" "${TMP}/sysupdate.list")
"
			;;
	esac
}

# Downgrade if an update caused an issue. Untested yet.
# Not tested yet
do_revert() {
	local _upd _u

	_upd=$(find /var/db/updates/ -type f -name "${1}.old.tgz")
	_u=${_upd##*/}

	unpriv -f "${TMP}/${_u}" "cp /var/db/updates/${_u} ${TMP}/"

	# Install the files. Keep the .old files where they are, which will allow them to be
	# tested and/or inspected further by the user. They will get removed once the faulty
	# update gets fixed.
	handle_tar -e "${TMP}/${_u}" -C "${TMP}"
	printf '%s\n' "Reverting ${_u%%.*}"
	install_files "${TMP}/${_u%%.*}"
}

# Cleanup after finish
cleanup() {
	set +e
	rm -rf "${TMP}"
}

trap 'cleanup' EXIT
trap exit HUP INT TERM

case "$1" in
	-d)	do_download "$2"
		;;
	-h)	usage
		;;
	-l)	do_list
		;;
	-q)	do_query
		;;
	-r)	do_revert "$2"
		;;
	*)	do_update
		;;
esac
